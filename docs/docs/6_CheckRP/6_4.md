# 6.4 リファレンスポイントのHU値のチェック

## 目的
リファレンスポイント近傍のHU値が極端に小さな、もしくは大きな値になっていないかを確認する。
リファレンスポイントのまわりのある半径を持つ球をぎりぎり含む直方体に含まれるVoxelのHU値の平均を返す関数を実装する。
実装ではリファレンスポイントがアイソセンターである場合になっている。

## 必要な情報
プランで用いられている画像、
プランのアイソセンター、
画像座標の原点、グリッドサイズ、グリッド幅
VoxelのHU値

## 与えられている引数

`PlanSetup`クラスのインスタンス`planSetup`、
許容するHU値の下限値`HuLowerThreshold`
許容するHU値の上限値`HuUpperThreshold`

## 必要な情報へのアクセス方法
- 現在開かれているプラン(`planSetup`)で用いられている画像の取得
  ```csharp
  var image = planSetup.StructureSet.Image;
  ```
- アイソセンター（一番目のビームのアイソセンター）の取得
  ```csharp
  var var isocenter = planSetup.Beams.First().IsocenterPosition;
  ```
- アイソセンターの座標の取得（1次元配列に格納）
  ```csharp
  var isocenterPosition = new double[] { isocenter.x, isocenter.y, isocenter.z };
  ```
- 画像座標の原点(`gridOrigin`)、グリッド幅（mm）(`gridReses`)、グリッドサイズ(`gridSizes`)の取得(それぞれ1次元配列に格納)
  ```csharp
  var gridOrigin = new double[] { image.Origin.x, image.Origin.y, image.Origin.z };
  var gridReses = new double[] { image.XRes, image.YRes, image.ZRes };
  var gridSizes = new int[] { image.XSize, image.YSize, image.ZSize };
  ```
- スライス`i`の画像の取得
  ```csharp
  image.GetVoxels(i, zImage);
  ```
  2次元配列`zImage`に画素値が格納される。1次元目がx方向、2次元目がy方向であることに注意。
- 画素値をHU値に変換
  ```csharp
  var value = image.VoxelToDisplayValue(zImage[k, j]);
  ```

## 実装
- アイソセンタを中心とした球内のHU値の平均を計算し、許容範囲かどうかを判定し、結果を返す関数

  ```csharp
      public static string CheckIsocenterHu(PlanSetup planSetup, double HuLowerThreshold, double HuUpperThreshold)
              {
  ```
- アイソセンタ座標の取得
  ```csharp
                  var isocenter = planSetup.Beams.First().IsocenterPosition;
                  var isocenterPosition = new double[] { isocenter.x, isocenter.y, isocenter.z };
  ```
- 画像、及びその原点、グリッド幅、グリッド数の取得
  ```csharp
                  var image = planSetup.StructureSet.Image;
                  var gridOrigin = new double[] { image.Origin.x, image.Origin.y, image.Origin.z };
                  var gridReses = new double[] { image.XRes, image.YRes, image.ZRes };
                  var gridSizes = new int[] { image.XSize, image.YSize, image.ZSize };
  ```
- 調べる範囲を決める球の半径（mm）の指定
  ```csharp
                  // radius of the sphere ROI in mm
                  double radius = 5;
  ```
- 調べる範囲の球を含むvoxel範囲の取得
  ```csharp
                  var gridRanges = GetGridRangesForSphere(radius, isocenterPosition, gridOrigin, gridReses, gridSizes);
  ```
- 球内のvoxel値を格納する配列の定義
  ```csharp
                  var voxels = new double[(gridRanges[3] - gridRanges[0] + 1) * (gridRanges[4] - gridRanges[1] + 1) * (gridRanges[5] - gridRanges[2] + 1)];
  ```
- 直方体内のvoxelを全て回るループ
  ```csharp
                  int numVoxels = 0;
                  double sum = 0;
                  var zImage = new int[image.XSize, image.YSize];
                  // Z
                  for (int i = gridRanges[2]; i <= gridRanges[5]; i++)
                  {
                      double z = image.Origin.z + i * image.ZRes;
                      image.GetVoxels(i, zImage);
                      // Y
                      for (int j = gridRanges[1]; j <= gridRanges[4]; j++)
                      {
                          double y = image.Origin.y + j * image.YRes;
                          // X
                          for (int k = gridRanges[0]; k <= gridRanges[3]; k++)
                          {
                              double x = image.Origin.x + k * image.XRes;
  ```
- voxelが球内に含まれるかを判定し、球外だと次のvoxelに移る。
    ```csharp

                                double r = Math.Sqrt(Math.Pow(isocenterPosition[0] - x, 2) + Math.Pow(isocenterPosition[1] - y, 2) + Math.Pow(isocenterPosition[2] - z, 2));
                                if (r > radius)
                                {
                                    continue;
                                }
    ```
- 球内のvoxelの値をHU値に変換し、voxelsに格納し、HU値の和を求めるための変数`sum`に加える。
  ```csharp
                              var value = image.VoxelToDisplayValue(zImage[k, j]);
                              voxels[numVoxels] = value;
                              sum += value;
                              numVoxels += 1;
                          }
                      }
                  }
  ```
- 球内のvoxel値の平均を計算し、結果を`result`に書き出し。
  ```csharp
                  var average = sum / numVoxels;
                  //MessageBox.Show(String.Format("numVoxels, sum, average: {0}, {1}, {2:0.0}", numVoxels, sum, average));
                  string result = String.Format("Averaged HU within the {0} mm sphere at Isocenter: {1:0.0}", radius, average);
                  
                  if (HuLowerThreshold < average && average < HuUpperThreshold)
                  {
                      return MakeFormatText(true, "Check Isocenter HU", "");
                  }
                  else
                  {
                      return MakeFormatText(false, "Check Isocenter HU", result);
                  }

              }
  ```
- 半径 radiusの球をぎりぎり含む直方体のVoxel範囲を返す補助関数
    ```csharp
    public static int[] GetGridRangesForSphere(double radius, double[] center, double[] gridOrigin, double[] gridReses, int[] gridSizes)
    {
        var gridRanges = new int[6];

        int iXCenter = (int)((center[0] - gridOrigin[0]) / gridReses[0]);
        int iYCenter = (int)((center[1] - gridOrigin[1]) / gridReses[1]);
        int iZCenter = (int)((center[2] - gridOrigin[2]) / gridReses[2]);

        int xRange = (int)(Math.Ceiling(radius / gridReses[0]));
        int yRange = (int)(Math.Ceiling(radius / gridReses[1]));
        int zRange = (int)(Math.Ceiling(radius / gridReses[2]));

        // Lower limits
        gridRanges[0] = iXCenter - xRange;
        if (center[0] - (gridOrigin[0] + gridRanges[0] * gridReses[0]) < radius)
        {
            gridRanges[0] -= 1;
        }
        gridRanges[1] = iYCenter - yRange;
        if (center[1] - (gridOrigin[1] + gridRanges[1] * gridReses[1]) < radius)
        {
            gridRanges[1] -= 1;
        }
        gridRanges[2] = iZCenter - zRange;
        if (center[2] - (gridOrigin[2] + gridRanges[2] * gridReses[2]) < radius)
        {
            gridRanges[2] -= 1;
        }

        // check if gridRanges is out of lower boundary
        if (gridRanges[0] < 0)
        {
            gridRanges[0] = 0;
        }
        if (gridRanges[1] < 0)
        {
            gridRanges[1] = 0;
        }
        if (gridRanges[2] < 0)
        {
            gridRanges[2] = 0;
        }

        // Upper limits
        gridRanges[3] = iXCenter + xRange;
        if ((gridOrigin[0] + gridRanges[3] * gridReses[0] - center[0]) < radius)
        {
            gridRanges[3] += 1;
        }
        gridRanges[4] = iYCenter + yRange;
        if ((gridOrigin[1] + gridRanges[4] * gridReses[1] - center[1]) < radius)
        {
            gridRanges[4] += 1;
        }
        gridRanges[5] = iZCenter + zRange;
        if ((gridOrigin[2] + gridRanges[5] * gridReses[2] - center[2]) < radius)
        {
            gridRanges[5] += 1;
        }

        // check if gridRanges is out of upper boundary
        if (gridRanges[3] >= gridSizes[0])
        {
            gridRanges[3] = gridSizes[0] - 1;
        }
        if (gridRanges[4] >= gridSizes[1])
        {
            gridRanges[4] = gridSizes[1] - 1;
        }
        if (gridRanges[5] >= gridSizes[2])
        {
            gridRanges[5] = gridSizes[2] - 1;
        }

        return gridRanges;
    }
    ```